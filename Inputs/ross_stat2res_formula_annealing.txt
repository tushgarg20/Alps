#Unit	GSIM residency			Comments
#Instance Counts				
	numROSS	=	SUM('knob\.S\d+\.NumSubSlices')	#Change to handle assymetric configs
	numEURows	=	knob.S0.SS0.NumRows	#We need a global knob here to support Assymetrical Slices in future
	num_ROSS_BC	=	numROSS	
	num_ROSS_PSD	=	numROSS	
	num_ROSS_PSD_Scoreboard	=	numROSS	
	num_ROSS_PSD_BaryPayloadRAM	=	numROSS	
	num_ROSS_MA_IN	=	numEURows * numROSS	#MA is per row
	num_ROSS_MA_OUT	=	numEURows * numROSS	#MA is per row
	num_ROSS_TDL	=	numROSS	
	num_ROSS_IC	=	numROSS	
	num_ROSS_IC_DataRAM	=	numROSS	
	num_ROSS_DAPRSS	=	numROSS	
	num_ROSS_DAPRSS_BypassRAM	=	numROSS	
	num_ROSS_GWL	=	numROSS	
	num_ROSS_SMALL	=	numROSS	
	num_ROSS_CLKGLUE	=	numROSS	
	num_ROSS_NONCLKGLUE	=	numROSS	
	num_ROSS_DFX	=	numROSS	
	num_ROSS_DOP	=	numROSS	
#Generic				
	 .CrClk	=	D(CrClock.Clocks)	
	 .UnsliceClk	=	D(UnsliceClock.Clocks)	
	.temp_3DPipeDisable	=	D(uCS0.pwr_3DPipeDisabled.UnsliceClock)/.UnsliceClk	
	 @ANY_BC@	=	S\d+\.SS\d+\.uBC\.	
	 @ANY_PSD@	=	S\d+\.SS\d+\.uPSD\.	
	 @ANY_MA_IN@	=	S\d+\.SS\d+\.R\d+\.uMAI\.	
	 @ANY_MA_OUT@	=	S\d+\.SS\d+\.R\d+\.uMAO\.	
	 @ANY_TDL@	=	S\d+\.SS\d+\.uTDL\.	
	 @ANY_ICACHE@	=	S\d+\.SS\d+\.uICACHE\.	
	 @ANY_DAPRF@	=	S\d+\.SS\d+\.uDAPRF\.	
	 @ANY_GWC@	=	Med\.uGWC\.	
#BC				
	PS0_BC	=	(D(SUM('@ANY_BC@pwr_bc_idle\.CrClock')) / (numROSS * .CrClk)) - PS0_BC_DOP	
	PS0_BC_DOP	=	0	#BC is not covered by 3D DOP
	PS1_BC	=	1 - (PS0_BC + PS0_BC_DOP + PS2_BC_COMPUTE + PS2_BC_FLOWTHROUGH)	
	PS2_BC_COMPUTE	=	D(SUM('@ANY_BC@pwr_bc_active_compute\.CrClock')) / (numROSS * .CrClk)	
	PS2_BC_FLOWTHROUGH	=	D(SUM('@ANY_BC@pwr_bc_active_flowthrough\.CrClock')) / (numROSS * .CrClk)	
	PS2_BC_BARYRAM_READ	=	0	#No GSIM model
	PS2_BC_BARYRAM_WRITE	=	0	#No GSIM model
#PSD				
	PS0_PSD	=	(D(SUM('@ANY_PSD@pwr_psd_idle\.CrClock')) / (numROSS * .CrClk)) - PS0_PSD_DOP	
	PS0_PSD_DOP	=	0	#PSD is not covered by 3D DOP
	PS1_PSD	=	(1 - (PS0_PSD + PS0_PSD_DOP + PS2_PSD_THREADDISPATCH + PS2_PSD_NOTHREADDISPATCH + PS2_PSD_WAITINGONFLUSH))	
	PS2_PSD_THREADDISPATCH	=	D(SUM('@ANY_PSD@pwr_PsdActiveThreadDispatch\.CrClock')) / (numROSS * .CrClk)	
	PS2_PSD_NOTHREADDISPATCH	=	D(SUM('@ANY_PSD@pwr_PsdActiveNoThreadDispatch\.CrClock')) / (numROSS * .CrClk)	
	PS2_PSD_WAITINGONFLUSH	=	D(SUM('@ANY_PSD@pwr_PsdWaitingOnFlush\.CrClock')) / (numROSS * .CrClk)	
#PSD SCOREBOARD				
	PS0_PSD_SCOREBOARD	=	0	
	PS2_PSD_SCOREBOARD_READ	=	D(SUM('@ANY_PSD@pwr_PsdScoreboardRead\.CrClock')) / (numROSS * .CrClk)	
	PS2_PSD_SCOREBOARD_WRITE	=	D(SUM('@ANY_PSD@pwr_PsdScoreboardWrite\.CrClock')) / (numROSS * .CrClk)	
#PSD BARY PAYLOAD RAM				
	PS0_PSD_BARYPAYLDASMRAM	=	0	
	PS2_PSD_BARYPAYLDASMRAM_READ	=	D(SUM('@ANY_PSD@pwr_PsdBaryPayloadAssemblyRAMRead\.CrClock')) / (numROSS * .CrClk)	
	PS2_PSD_BARYPAYLDASMRAM_WRITE	=	D(SUM('@ANY_PSD@pwr_PsdBaryPayloadAssemblyRAMRead\.CrClock')) / (numROSS * .CrClk)	
#MA IN				
	PS0_MA_IN	=	D(SUM('@ANY_MA_IN@pwr_MAIn_Idle\.CrClock')) / (numEURows * numROSS * .CrClk)	
	PS1_MA_IN	=	1 - PS0_MA_IN - PS2_MA_IN	
	PS2_MA_IN	=	D(SUM('@ANY_MA_IN@pwr_MAIn_Active\.CrClock')) / (numEURows * numROSS * .CrClk)	
#MA OUT				
	PS0_MA_OUT	=	D(SUM('@ANY_MA_OUT@pwr_MAOut_Idle\.CrClock')) / (numEURows * numROSS * .CrClk)	
	PS1_MA_OUT	=	1 - PS0_MA_OUT - PS2_MA_OUT	
	PS2_MA_OUT	=	D(SUM('@ANY_MA_OUT@pwr_MAOut_Active\.CrClock')) / (numEURows * numROSS * .CrClk)	
#TDL				
	PS0_TDL	=	D(SUM('@ANY_TDL@pwr_TDL_Idle\.CrClock')) / (numROSS * .CrClk)	
	PS1_TDL	=	(1 - (PS0_TDL + PS2_TDL_PSDDISPATCH + PS2_TDL_NONPSDDISPATCH))	
	PS2_TDL_PSDDISPATCH	=	D(SUM('@ANY_TDL@pwr_TDL_PSDDispatch\.CrClock')) / (numROSS * .CrClk)	
	PS2_TDL_NONPSDDISPATCH	=	D(SUM('@ANY_TDL@pwr_TDL_NonPSDDispatch\.CrClock')) / (numROSS * .CrClk)	
#IC				
	PS0_IC	=	D(SUM('@ANY_ICACHE@pwr_IC_Idle\.CrClock')) / (numROSS * .CrClk)	
	PS1_IC	=	1 - PS0_IC - PS2_IC	
	PS2_IC	=	D(SUM('@ANY_ICACHE@pwr_IC_Active\.CrClock')) / (numROSS * .CrClk)	
#IC DATARAM				
	PS0_IC_DATARAM	=	0	
	.temp_PS2_IC_DATARAM_READ	=	D(SUM('@ANY_ICACHE@pwr_IC_Reads\.CrClock')) / (numROSS * .CrClk)	
	PS2_IC_DATARAM_FRONTBUFFER_READ	=	D(SUM('@ANY_ICACHE@pwr_IC_Front_Buffer_Hits\.CrClock')) / (numROSS * .CrClk)	
	PS2_IC_DATARAM_READ	=	.temp_PS2_IC_DATARAM_READ - PS2_IC_DATARAM_FRONTBUFFER_READ	
	PS2_IC_DATARAM_WRITE	=	D(SUM('@ANY_ICACHE@pwr_IC_Writes\.CrClock')) / (numROSS * .CrClk)	
				
#DAPRSS				
	PS0_DAPRSS	=	(D(SUM('@ANY_DAPRF@pwr_DAPRF_Idle\.CrClock')) / (numROSS * .CrClk)) - PS0_DAPRSS_DOP	
	PS0_DAPRSS_DOP	=	0	#DAPRSS is not covered by 3D DOP
	PS1_DAPRSS	=	(D(SUM('@ANY_DAPRF@pwr_DAPRF_Stalled_or_Idle\.CrClock')) - D(SUM('@ANY_DAPRF@pwr_DAPRF_Idle\.CrClock'))) / (numROSS * .CrClk)	
	PS2_DAPRSS_WRITEFLUSH	=	D(SUM('@ANY_DAPRF@pwr_DAPRF_FlushMsgsFromPSD\.CrClock')) / (numROSS * .CrClk)	
	PS2_DAPRSS_RENDERTARGETWRITE	=	D(SUM('@ANY_DAPRF@pwr_DAPRF_RenderTargetWrite\.CrClock')) / (numROSS * .CrClk)	
	PS2_DAPRSS_CLEARRESOLVE	=	(D(SUM('@ANY_DAPRF@pwr_DAPRF_RTResolveMsgs\.CrClock')) + D(SUM('@ANY_DAPRF@pwr_DAPRF_RTFastClear\.CrClock')))/ (numROSS * .CrClk)	
	PS2_DAPRSS_RENDERTARGETREAD	=	D(SUM('@ANY_DAPRF@pwr_DAPRF_RenderTargetRead\.CrClock')) / (numROSS * .CrClk)	
	PS2_DAPRSS_ELSE	=	D(SUM('@ANY_DAPRF@pwr_DAPRF_BypassMsgs\.CrClock')) / (numROSS * .CrClk)	
#DAPRSS BYPASS RAM				
	PS0_DAPRSS_BYPASSRAM	=	0	#ROSS units are not covered by 3D DOP
	PS2_DAPRSS_BYPASSRAM_READ	=	D(SUM('@ANY_DAPRF@pwr_DAPRF_HDRBypassRamRd\.CrClock')) / (numROSS * .CrClk)	
	PS2_DAPRSS_BYPASSRAM_WRITE	=	D(SUM('@ANY_DAPRF@pwr_DAPRF_HDRBypassRamWr\.CrClock')) / (numROSS * .CrClk)	
#GWL				
	PS0_GWL	=	D(SUM('@ANY_GWC@pwr_GWC_Idle\.CrClock')) / (.CrClk)	#GWC is 1 in count
	PS1_GWL	=	1 - PS0_GWL - PS2_GWL	
	PS2_GWL	=	D(SUM('@ANY_GWC@pwr_GWC_Active\.CrClock')) / (.CrClk)	#GWC is 1 in count
				
#Small				
	PS0_ROSS_SMALL_DOP	=	0	#ROSS units are not covered by 3D DOP
	PS0_ROSS_SMALL	=	1 - PS0_ROSS_SMALL_DOP - PS2_ROSS_SMALL	
	.temp_PS2_BC	=	PS2_BC_COMPUTE + PS2_BC_FLOWTHROUGH + PS2_BC_BARYRAM_READ + PS2_BC_BARYRAM_WRITE	
	.temp_PS2_PSD	=	PS2_PSD_THREADDISPATCH + PS2_PSD_NOTHREADDISPATCH + PS2_PSD_WAITINGONFLUSH	
	.temp_PS2_TDL	=	PS2_TDL_PSDDISPATCH + PS2_TDL_NONPSDDISPATCH	
	.temp_PS2_DAPRSS	=	PS2_DAPRSS_WRITEFLUSH + PS2_DAPRSS_RENDERTARGETWRITE + PS2_DAPRSS_CLEARRESOLVE + PS2_DAPRSS_RENDERTARGETREAD + PS2_DAPRSS_ELSE	
	PS2_ROSS_SMALL	=	MAX(.temp_PS2_BC, .temp_PS2_PSD, PS2_MA_IN, PS2_MA_OUT, .temp_PS2_TDL, PS2_IC, .temp_PS2_DAPRSS, PS2_GWL)	
				
#CLKGLUE				
	PS0_ROSS_CLKGLUE_DOP	=	0	#ROSS units are not covered by 3D DOP
	PS0_ROSS_CLKGLUE	=	PS0_ROSS_SMALL	
	PS2_ROSS_CLKGLUE	=	PS2_ROSS_SMALL	
				
#NONCLKGLUE				
	PS0_ROSS_NONCLKGLUE_DOP	=	0	#ROSS units are not covered by 3D DOP
	PS0_ROSS_NONCLKGLUE	=	PS0_ROSS_SMALL	
	PS2_ROSS_NONCLKGLUE	=	PS2_ROSS_SMALL	
				
#Dfx				
	PS0_ROSS_DFX_DOP	=	0	#ROSS units are not covered by 3D DOP
	PS0_ROSS_DFX	=	PS0_ROSS_SMALL	
	PS2_ROSS_DFX	=	PS2_ROSS_SMALL	
				
#DOP				
	PS0_ROSS_DOP	=	0	#ROSS units are not covered by 3D DOP
	PS2_ROSS_DOP	=	1 - PS0_ROSS_DOP	
				
				
#ANNEALING				
	PS2_BC	=	PS2_BC_FLOWTHROUGH+PS2_BC_COMPUTE	
				
				
	PS2_PSD	=	PS2_PSD_THREADDISPATCH+PS2_PSD_NOTHREADDISPATCH+PS2_PSD_WAITINGONFLUSH	
				
				
	PS2_TDL	=	PS2_TDL_PSDDISPATCH+PS2_TDL_NONPSDDISPATCH	
				
				
	PS2_DAPRSS	=	PS2_DAPRSS_WRITEFLUSH+PS2_DAPRSS_RENDERTARGETWRITE+PS2_DAPRSS_CLEARRESOLVE+PS2_DAPRSS_RENDERTARGETREAD+PS2_DAPRSS_ELSE	
				
				
#GLUE				
	num_ROSS_GLUE	=	numROSS	
	PS0_ROSS_GLUE_DOP	=	.temp_3DPipeDisable	
	PS0_ROSS_GLUE	=	PS0_ROSS_SMALL	
	PS2_ROSS_GLUE	=	PS2_ROSS_SMALL	
